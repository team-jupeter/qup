alias Demo.Accounts.Account
alias Demo.Repo
import Ecto.Query, only: [from: 2]


{ok, mike} = %Account{} |>
        Account.changeset(%{email: "mike@subvisual.com"}) |>
        Repo.insert()

{ok, mary} = %Account{} |>
        Account.changeset(%{email: "mary@subvisual.com"}) |>
        Repo.insert()

{ok, john} = %Account{} |>
        Account.changeset(%{email: "john@subvisual.com"}) |>
        Repo.insert()




#? 1. Check if the bank account exists
#? 2. Create one with the balance if not
#? 3. Update the existing one adding to the previous balance if yes
attrs = %{email: "mike@subvisual.com", balance: Decimal.new(50)}

# %Account{}
# |> Account.changeset(attrs)
# |> Repo.insert(
#   on_conflict: [inc: [balance: attrs.balance]],
#   conflict_target: :email,
#   returning: true
# )

on_conflict = from(a in Account, where: not a.locked, update: [inc: [balance: ^balance]])

#? 1. The records from which it will select are the subset that triggered the conflict, not the entire dataset
#? 2. The updates will be ran via an update_all, which do not update autogenerated fields, for example
%Account{}
|> Account.changeset(attrs)
|> Repo.insert(
  on_conflict: on_conflict,
  conflict_target: :email,
  stale_error_field: :email, # StaleEntryError
  returning: true
)


##
mary_update =
  from Account,
    where: [id: ^mary.id],
    update: [inc: [balance: +10]]

john_update =
  from Account,
    where: [id: ^john.id],
    update: [inc: [balance: -10]]

Ecto.Multi.new() |>
  Ecto.Multi.update_all(:mary, mary_update) |>
  Ecto.Multi.update_all(:john, john_update)
